---
layout:     post
title:      LeetCode 116 填充每个节点的下一个右侧节点指针
date:       2019-07-13
author:     xflyme
header-img: img/post-bg-2019-07-13.jpg
catalog: true
tags:
    - 算法
    - LeetCode
    - 二叉树
---

### 题目
给定一个**完美二叉树**，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
```java
struct Node {
  int val;
  Node left;
  Node right;
  Node next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

#### 示例

![图一](/img/leetcode-116-1.png)

#### 提示
* 你只能使用常量级额外空间。
* 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。

### 思路
这一题其实就是把每一层的节点横向连接起来，第一想法就是层序遍历。我们先回顾一下层序遍历怎么写：
* 两个指针一个指向本层最后一个节点，一个指向下一层最后一个节点。
* 一个队列本层的出队，同时下一层的入队，遇到本层尾节点，换行。

代码如下：
```java
void printByLevel(TreeNode treeNode) {

        /*
         * Q:什么情况下表示该换行了 Q:什么情况下表示已经遍历完所有数据
         */

        /*
         * A:当前节点指向当前行最后一个元素时表示该换行了 A:链表数据为空时表示已经遍历完所有数据
         */

        /*
         * 把所有元素添加到链表 一个指针记录当前行的最后一个元素 一个指针记录下一行的最后一个元素
         */

        TreeNode currentLast = treeNode;
        TreeNode nextLast = treeNode;
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.offer(treeNode);

        while (!queue.isEmpty()) {

            TreeNode node = queue.poll();
            System.out.print(node.value);

            if (node.leftNode != null) {
                queue.offer(node.leftNode);
                nextLast = node.leftNode;
            }

            if (node.rightNode != null) {
                queue.offer(node.rightNode);
                nextLast = node.rightNode;
            }

            if (node == currentLast) {
                currentLast = nextLast;
                System.out.println("");
            }
        }
```

* 时间复杂度 O(n)每个节点访问一次。
* 空间复杂度 O(n/2)也就是 O(n)。

空间复杂度好像不太符合题目的要求，代码提交之后时间也只达到 50% 的水平。还有哪里可以优化的？

![图一](/img/leetcode-116-1.png)

我们再看一下这张图，红色的线把每一层的节点都连了起来，我们可以不用队列来盛放层节点了。

### 解法

```java
 public static Node connect(Node root) {
        if (root == null) return root;

        Node current = root;
        //当前层第一个节点
        Node levelFirst = root;
        //当前层最后一个节点
        Node levelLast = root;

        while (current.left!=null) {
            //两个孩子连接
            current.left.next = current.right;
            if (current == levelLast){
                //换行
                //左等于左的左
                levelFirst = levelFirst.left;
                //右等于右的右
                levelLast = levelLast.right;
                current = levelFirst;
            }else{
                //当前节点和下一节点连接
                current.right.next = current.next.left;
                //后移一位
                current = current.next;
            }
        }

        return root;
    }
```

### 其他方法
[LeetCode 上有个拉链式解法](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/solution/la-la-lian-jie-fa-by-sorcerer/)，这个方法很有意思。

```java
 public static Node connect(Node root) {
        if (root == null) return root;
        Node left = root.left;
        Node right = root.right;
        while (left != null) {
            left.next = right;
            left = left.right;
            right = right.left;
        }
        connect(root.left);
        connect(root.right);
        return root;
    }
```
题目中给出的是**完美二叉树**，所以可以先把左子树的右节点和右子树的左节点连接起来，然后递归。
如图：

![图二](/img/leetcode-116-2.jpeg)
