---
layout:     post
title:      LeetCode 5 最长回文子串
date:       2018-03-21
author:     xflyme
header-img: img/post-bg-2018-03-21.jpg
catalog: true
tags:
    - 算法
    - LeetCode
    - 字符串
---


#### 题目

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

#### 示例
> 输入: "babad"
   输出: "bab"
   注意: "aba" 也是一个有效答案。
   
#### 思路
要做出这一题首先我们要知道什么是回文串，先列出几个回文串：
"a"
"aa"
"aba"
它们有什么特点？特点其实是【回文串都有一个中心，这个回文串关于这个中心对称，这个中心可能是一个字符，也可能是在两个字符中间】。
找出这个特点了，那么我们怎么用算法来实现它？
根据上面的特点，我们看一下一个长度为 n 字符串有多少个【中心】。每个字符都是中心，它们的数量是 n，两个字符中间也有一个中心它们的数量是 n-1，【中心】的总量是 2n-1。
找出中心了，下一步就是遍历这些中心，然后找出最长回文子串。

#### 代码
```java
public String longestPalindrome(String s) {

             if (s == null || s.length() == 0) {

                   return "";

             }

             char[] chars = s.toCharArray();

             int n = chars.length;

             int start = 0;

             int end = 0;

             int maxLength = 0;



             //数组下标要特别注意

             for (int i = 0; i <= 2 * n - 1; i++) {

                   int length = getLongestPalindrome(chars, i / 2, (i + 1) / 
2);

                   if (length > maxLength) {

                          //长度为 length 的字符串，它的尾标-首标的距离其实是 
<u>leng</u> -1

                          start = (i + 1) / 2 - length / 2;

                          end = (i + 1) / 2 + (length - 1) / 2;

                          maxLength = length;

                   }

             }



             return s.substring(start, end + 1);

      }



      public int getLongestPalindrome(char[] chars, int l, int r) {

             int left = l, right = r;

             while (left >= 0 && right < chars.length && chars[left] == 
chars[right]) {

                   left--;

                   right++;

             }

             //当前回文串的长度

             //left 指向回文串前面一位，right 指向回文串后一位 

             //回文串夹在中间，减一才是回文串的真正长度

             return right - left - 1;

      }
```

