---
layout:     post
title:      LeetCode 1 两数之和
date:       2018-02-15
author:     xflyme
header-img: img/post-bg-2018-02-15.png
catalog: true
tags:
    - 算法
    - LeetCode
---


#### 题目
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

#### 示例：
> 给定 nums = [2, 7, 11, 15], target = 9
>因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]

#### 思路
这一题是很简单的一道题，可以利用 HashMap 的特性。
* 时间复杂度 O(n)
* 空间复杂度也是 O(n)
有人说 HashMap 肯能退化成链表，所以时间复杂度不是 O(n)。

> 大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势。

虽然 HashMap 扩容的时候会有数据的拷贝，严重退化的时候也可能所有数据都存储在一个链表里。但是大部分情况下 HashMap 的时间复杂度都是 O(1)，它的均分复杂度也是 O(1)。所以这一题 HashMap 并不会增加时间复杂度。

代码如下：

```java
public int[] twoSum(int[] nums, int target) {

        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
        for (int i = 0; i < nums.length; i++) {
           // 如果当前的数据和已经遍历的某一个数据的和等于 target 返回
            if (map.containsKey(target - nums[i])) {

                return new int[] { map.get(target - nums[i]), i };
            }

            map.put(nums[i], i);
        }

        return null;
    }
```