---
layout:     post
title:      LeetCode 142 环形链表 II
date:       2018-03-28
author:     xflyme
header-img: img/post-bg-2018-03-28.jpeg
catalog: true
tags:
    - 算法
    - LeetCode
    - 链表
---


#### 题目
给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

说明：不允许修改给定的链表。

#### 示例
> 输入：head = [3,2,0,-4], pos = 1
输出：tail connects to node index 1
解释：链表中有一个环，其尾部连接到第二个节点。

![图一](/img/leetcode-152-1.png)

> 输入：head = [1], pos = -1
输出：no cycle
解释：链表中没有环。

![图二](/img/leetcode-152-2.png)

#### 解法一
可以利用 HashMap 来存储已经遍历过的节点，如果后续的节点在 Map 中已经存在，说明有环，否则无环。

```java
public static ListNode detectCycleWithSet(ListNode head) {

             Set<ListNode> set = new HashSet<ListNode>();

             while (head != null) {

                   if (set.contains(head)) {

                          return head;

                   }

                   set.add(head);

                   head = head.next;

             }

             return null;

      }

```

#### 解法2 
判断链表中有没有环的另一种解法是快慢指针，如果快指针能追上慢指针说明有环，否则无环。但是这题不仅仅要求判断有没有环，还要将环的入口找到。
怎么找到环的入口？我们先画一个图，看能不能找到有用的信息。

![图三](/img/leetcode-152-3.jpg)

如图所示，快指针追上慢指针说明快指针移动的距离是慢指针的两倍。
所以 2(a+b) = a + 2b+ c
       2a+2b = a + 2b+c
              a = c
              
现在相遇点到环起点的距离跟表头到环起点的距离相等。第二步我们同样要用两个指针，一个指向表起点，一个指向相遇点，他们同样每次一步的往下走，这次相遇的点就是环起点。
 
 #### 代码
 ```java
public static ListNode detectCycleWithIndex(ListNode head) {

             ListNode p = head;
             ListNode q = head;

             while (p != null && p.next != null) {
                   p = p.next.next;
                   q = q.next;
                   if (p == q) {
                          return findTargetNode(head, p);
                   }
             }
             return null;
      }


      public static ListNode findTargetNode(ListNode head, ListNode p) {

             while (true) {
                   if (p == head) {
                          return p;
                   }
                   p = p.next;
                   head = head.next;
             }

      }

```

#### 证明

代码已经写完了，不过这里还有几个问题。
  
1.  这里有一个问题，有没有可能第一圈没有遇到，第二圈才遇到。
 2. 如果不是第一圈相遇，第二步的两个指针还能在环起点碰头吗？
 3. 有没有可能快指针每次都跳过慢指针的那个点他们永远不会指向同意节点

![图四](/img/leetcode-152-4.png)

如图，环中的节点从 0 到 C−1 编号，其中 C 是环的长度。非环节点从 -F 到 -1 编号，其中 F 是环以外节点的数目。 F 次迭代以后，慢指针指向了 0 且快指针指向某个节点 h ，其中 F≡h(modC) 。

    注意，这里有几个点需要弄清楚
    1. h 是某个节点的编号，而不是长度。
    2. F≡h(modC) F、C 都不是负数，这里我们可以理解为 F 除 C 之后的余数为 h。
    F 大于 C 或小于 C 在这里都没有影响，假设 C = 5，F = 3，那么 h = 3；
    假设 C = 3 ，F= 5，那么 h =2，相当于快指针在环中走了一圈又回到编号为 2 的节点。
    
现在慢指针在环的入口，快指针距入口的距离为 C-h，那么理论上再经过 C-h 次迭代，两个指针就能相遇。我们来看下是不是这样。
经过 C-h 次迭代之后快指针移动了 2(C-h)。
                                 
     2(C-h)+h = 2C - h而 2C-h ≡ C-h(modC)

两个都指向 C-h 节点，也就是说他们一定会相遇。

现在我们来看另一个问题，相遇归相遇，但是第二步两个节点一定能在环入口相遇？

    上面我们计算过 F≡h(modC) ，也就是说第二步的时候环中的指针向前移动了 h 距离。
    (C - h)+h = C，刚好移动到环入口。

