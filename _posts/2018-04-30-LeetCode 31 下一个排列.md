---
layout:     post
title:      LeetCode 30 下一个排列
date:       2018-04-30
author:     xflyme
header-img: img/post-bg-2018-04-30.jpg
catalog: true
tags:
    - 算法
    - LeetCode
    - 数组
---


#### 题目
实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。

#### 示例
  
    1,2,3 → 1,3,2
    3,2,1 → 1,2,3
    1,1,5 → 1,5,1
    
#### 思路

两个问题
* 什么样的排列可以有更大的排列
* 怎么找的下一个更大的排列

刚开始想到的是，从大到小排列肯定没有更大的排列，所以从前往后如果存在后面的数字大于前面的数字，说明这个排列有更大的排列。
那么怎么周到呢？
首先想到的是，从前往后遍历遇到后面比前面大的交换。
验证一下

    1，5，3，4 → 5，1，3，4

不行。

![3bb9f80531809c7a369a5af4ca4505bd.png](evernotecid://E49FED88-ABD8-4F8F-880B-38CF8ACFB6AC/appyinxiangcom/2184113/ENResource/p2235)

看一下这个图，这样看更明显，从后往前找。最大的排列数字应该是一直上升的，如果某个数字突然下降了，那么这个数就是应该换位置的数，跟谁换，第一个比他大的数，在这个例子中也就是 3 和 4.

但是换完就够了吗？46321 显然比 41236 大，交换完之后后面只要一个最小的排列就行了，也就是要做一次升序排列。其实交换过后本就是排列好的，只要做一次反转就行了。

#### 代码

```java
public void nextPermutation(int[] nums) {
        if (nums == null || nums.length <= 1) {
            return;
        }

        int i = nums.length - 2;
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }

        if (i >= 0) {
            int j = nums.length - 1;
            while (j >= 0 && nums[i] >= nums[j]) {
                j--;
            }
            swap(nums, i, j);
        }

        reverse(nums, i + 1);
    }

    public void reverse(int[] nums, int index) {
        int i = index, j = nums.length - 1;
        while (i < j) {
            swap(nums, i, j);
            i++;
            j--;
        }

    }

    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
```
