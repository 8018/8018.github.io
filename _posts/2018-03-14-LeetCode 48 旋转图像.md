---
layout:     post
title:      LeetCode 4 旋转图像
date:       2018-03-14
author:     xflyme
header-img: img/post-bg-2018-03-14.jpg
catalog: true
tags:
    - 算法
    - LeetCode
    - 数组
---


#### 题目
给定一个 n × n 的二维矩阵表示一个图像。

将图像顺时针旋转 90 度。

说明：

你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。

#### 示例
>给定 matrix = 
>[
> [1,2,3],
> [4,5,6],
> [7,8,9]
>],

>原地旋转输入矩阵，使其变为:
>[
>  [7,4,1],
>  [8,5,2],
>  [9,6,3]
>]

#### 思考
题目中有要求不能用另外一个矩阵来旋转，所以我们只能用原地排序。

先画一个矩阵图，看能不能找出规律。

![pic-1](/img/leetcode-48-1.png)

图画出来其实很明显，就是按上图所示的顺时针旋转。但是数组下标是怎么改变的？我们可以把一组数的下标列出来，看能不能找到规律。


> (0,3)   ->  (3,4)
> (3,4)   ->  (4,1)
> (4,1)   ->  (1,0)
> (1,0)   ->  (0,3)

可以试着写一下它们的转换公式，然后多写几组数据验证公式是否正确。
这里直接给出结果：
> (i,j)                       ->  (j,n - i - 1)
> (j,n - i - 1)              ->  (n - i - 1,n - j - 1)
> (n - i - 1,n - j - 1)    ->  (n - j - 1,i)
> (n - j 1,i                 ->  (i,j)

#### 边界
从上图可以看出，当指针移动到 8 这个数字的时候，也就没必要再继续走了，它右边和下边的数字在之前的变换中都已经被换过位置。
所以坐标范围是 i < (n+1)/2, j < n/2，当然 i < n/2, j < (n+1)/2 也行。

变换公式和边界都已经写出来，代码也就很简单了。

#### 代码
```java
public static void rotateMatrix(int[][] matrix) {

             int n = matrix.length;

             for (int i = 0; i < (n + 1) / 2; i++) {

                   for (int j = 0; j < n / 2; j++) {

                          int temp = matrix[i][j];

                          matrix[i][j] = matrix[n - j - 1][i];

                          matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];

                          matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];

                          matrix[j][n - i - 1] = temp;

                   }

             }

      }
```

