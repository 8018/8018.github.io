---
layout:     post
title:      LeetCode 42 接雨水
date:       2018-05-06
author:     xflyme
header-img: img/post-bg-2018-05-06.jpg
catalog: true
tags:
    - 算法
    - LeetCode
    - 数组
---


#### 题目

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

#### 示例
    
    输入: [0,1,0,2,1,0,1,3,2,1,2,1]
    输出: 6

![图一](leetcode-41-1.png)

#### 思路

##### 什么情况下可以存储水

这一题的关键其实是找出什么状态下可以存储雨水。

![图二](leetcode-41-2.png)

![图三](leetcode-41-3.png)

这两张图显然不行，它没有存储水的空间。

![图四](leetcode-41-4.png)

这是一个典型的【桶】，它两边高中间低，可以保存水在它的内部。

##### 找出所有的桶
想要把一个桶一份为二需要怎么做？
当然是中间加上一块木板，这块【木板】需要什么条件？
如果这块木板高度低于原来桶的最短板，它将会被没于水下。所以新添加的【木板】要高于原来桶的最短板。

其实等于也行，这里我们选高于，将等于或低于短板的视为【砖块】，这些砖块侵占了桶的空间。

分析完之后代码其实很简单，如下：

![图五](leetcode-41-5.png)

#### 解法

```java
      public static int trap(int[] height) {
             if (height == null || height.length <= 2) {
                   return 0;
             }
             return trap(height, 0, height.length - 1);
      }



      public static int trap(int[] height, int startIndex, int endIndex) {
             if (endIndex - startIndex <= 1) {
                   return 0;
             }

             //桶的两边比较低的一边

             int minHeight = Math.min(height[startIndex], height[endIndex]);
             int minIndex = startIndex;

             //找到能将桶一份为 2 的那个值
             //比上面记录的“桶”的短板高的那个
             for (int i = startIndex + 1; i < endIndex; i++) {
                   if (height[i] > minHeight) {
                          minHeight = height[i];
                          minIndex = i;
                   }
             }

             //两个桶的容量和
             if (minIndex != startIndex) {
                   return trap(height, startIndex, minIndex) + trap(height, minIndex, endIndex);
             }



             //桶的容量
             int capacity = minHeight * (endIndex - startIndex - 1);

             //减去中间可能存在的“砖块”
             for (int i = startIndex + 1; i < endIndex; i++) {
                   capacity -= height[i];

             }
             return capacity;
      }

```
