---
layout:     post
title:      LeetCode 23 合并k个有序链表
date:       2018-04-04
author:     xflyme
header-img: img/post-bg-2018-04-04.jpeg
catalog: true
tags:
    - 算法
    - LeetCode
    - 链表
---


#### 题目

合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。

#### 示例
> 输入:
> [
>  1->4->5,
>  1->3->4,
>  2->6
> ]
> 输出: 1->1->2->3->4->4->5->6

#### 思路
暴力法可以直接忽略，这里可以使用分治的思想，先把数组一分为二的拆分，然后再两两合并，直至最后合并成一个链表 。

#### 复杂度
* 时间复杂度 O(n∗log(k))，其中 n 是节点的总数，k 是数组的长度
* 空间复杂度 O(1) 

#### 代码
```java
public static ListNode mergeKLists(ListNode[] lists) {
             if (lists == null || lists.length == 0) {
                   return null;
             }
             return mergeSortLists(lists, 0, lists.length - 1);

      }

      public static ListNode mergeSortLists(ListNode[] lists, int start, int end) {

             if (start == end) {
                   return lists[start];
             }

             int m = (start + end) / 2;
             return mergeNode(mergeSortLists(lists, start, m), mergeSortLists(lists, m + 1, end));
      }



      public static ListNode mergeNode(ListNode node1, ListNode node2) {

             if (node1 == null && node2 == null) {
                   return null;
             }

             if (node1 == null) {
                   return node2;
             }

             if (node2 == null) {
                   return node1;
             }

             ListNode mergedNode = new ListNode(0);
             ListNode nextNode = mergedNode;

             while (node1 != null && node2 != null) {

                   if (node1.val <= node2.val) {
                          nextNode.next = node1;
                          nextNode = nextNode.next;
                          node1 = node1.next;
                   } else {
                          nextNode.next = node2;
                          nextNode = nextNode.next;
                          node2 = node2.next;
                   }
             }

             while (node1 != null) {
                   nextNode.next = node1;
                   nextNode = nextNode.next;
                   node1 = node1.next;
             }

             while (node2 != null) {
                   nextNode.next = node2;
                   nextNode = nextNode.next;
                   node2 = node2.next;
             }

             return mergedNode.next;
      }

```
