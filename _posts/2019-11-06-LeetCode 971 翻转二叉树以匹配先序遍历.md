---
layout:     post
title:      LeetCode 971 翻转二叉树以匹配先序遍历
date:       2019-11-06
author:     xflyme
header-img: img/post-bg-2019-11-06.jpeg
catalog: true
tags:
    - LeetCode
    - 算法
    - 二叉树
---


#### 题目

给定一个有 N 个节点的二叉树，每个节点都有一个不同于其他节点且处于 {1, ..., N} 中的值。

通过交换节点的左子节点和右子节点，可以翻转该二叉树中的节点。

考虑从根节点开始的先序遍历报告的 N 值序列。将这一 N 值序列称为树的行程。

（回想一下，节点的先序遍历意味着我们报告当前节点的值，然后先序遍历左子节点，再先序遍历右子节点。）

我们的目标是翻转最少的树中节点，以便树的行程与给定的行程 voyage 相匹配。 

如果可以，则返回翻转的所有节点的值的列表。你可以按任何顺序返回答案。

如果不能，则返回列表 [-1]。

#### 示例
##### 示例1
![图一](/img/leetcode-971-1.png)
> 输入：root = [1,2], voyage = [2,1]
输出：[-1]

##### 示例2
![图二.png](/img/leetcode-971-2.png)
> 输入：root = [1,2,3], voyage = [1,3,2]
输出：[1]

#### 思路

这一题开始陷入一个误区：
> 二叉树是否是完全二叉树，不是完全二叉树的话树中的节点怎么跟数组中数据产生映射来对比结果。

最后仔细看了一下题目，它要求的是先序遍历的行程跟数组的行程做对比。我们可以用一个 index 记录已经遍历的节点数——也就是数组下标。然后取数组中的下一个数据跟当前节点的左右孩子比较。
如果有一个相等说明行程可以继续下去，否则返回 -1。

#### 解法

```java
int index = 0;

    public List<Integer> flipMatchVoyage(TreeNode root, int[] voyage) {
        List<Integer> result = new ArrayList<>();
        iterator(root, voyage, result);
        return result;
    }

    public void iterator(TreeNode root, int[] voyage, List<Integer> result) {
        if ((root.left == null && root.right == null) || index >= voyage.length) {
            return;
        }

        if (root.val != voyage[index]){
            result.clear();
            result.add(-1);
        }

        int nextValue = voyage[index + 1];

        int leftValue = -1;
        int rightValue = -1;
        if (root.left != null) {
            leftValue = root.left.val;
        }

        if (root.right != null) {
            rightValue = root.right.val;
        }

        //判断两个孩子节点的值是否有一个和数组中下一个 value 相等
        //不相等说明 voyage 不匹配
        if (leftValue != nextValue && rightValue != nextValue) {
            result.clear();
            result.add(-1);
            return;
        }

        //如果右孩子和下一个 value 相等 交换左右节点
        if (root.right != null && root.right.val == nextValue) {

            if (root.left != null) {
                result.add(voyage[index]);
            }

            TreeNode temp = root.left;
            root.left = root.right;
            root.right = temp;


        }

        index = index + 1;
        iterator(root.left, voyage, result);

        if (root.right != null) {
            //这里要再判断一次 漏掉会出错
            //因为上面的判断已经被消费
            nextValue = voyage[index + 1];
            if (nextValue != root.right.val){
                result.clear();
                result.add(-1);
                return;
            }

            index = index + 1;
            iterator(root.right, voyage, result);
        }

    }
```

官方解放简练很多，推荐[官方解法](https://leetcode-cn.com/problems/flip-binary-tree-to-match-preorder-traversal/solution/fan-zhuan-er-cha-shu-yi-pi-pei-xian-xu-bian-li-by-/)。
